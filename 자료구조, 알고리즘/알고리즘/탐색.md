# 탐색

   ## 순차 탐색

* 탐색은 여러 데이터 중에서 원하는 데이터를 찾아내는 것을 의미
* 데이터가 담겨있는 리스트를 앞에서 하나씩 비교해서 원하는 데이터를 찾는 방법



## 아주 간단한 탐색

~~~java
import java.util.ArrayList;

public class SequencialSearch {
  public int searchFunc(ArrayList<Integer> dataList, Integer searchitem) {
    for (int i = 0 ; i < dataList.size() ; i++) {
      if(dataList.get(i) == searchitem) {
        return i;
      }
    }
    return -1;
  }

  public static void main(String[] args) {
    ArrayList<Integer> testList = new ArrayList<Integer>();
    for(int i = 0 ; i < 100 ; i++) {
      testList.add((int)(Math.random() * 100));
    }
    SequencialSearch sSearch = new SequencialSearch();
    System.out.println(testList.toString());
    System.out.println(sSearch.searchFunc(testList, 5));
  }
}
~~~



## 이진 탐색

* Sequencial Search의 경우 데이터 정렬 상관 없이, 앞 부터 데이터 탐색
* 이진 탐색의 경우 데이터 정렬이 되어있다는 상태에서, 전체 데이터 개수 / 2 에서 데이터 값을 확인 후
* 데이터를 비교한 후
* 크면 그 뒤쪽 데이터 개수 / 2 위치에 데이터를 찾고 데이터 비교
* 무한 루프



### 분할 정복 알고리즘

* 분할 정복 알고리즘
  * Divide : 문제를 하나 또는 둘 이상으로 나눈다.
  * Conquer : 나눠진 문제가 충분히 작고, 해결이 가능하다면 해결하고, 그렇지 않다면 다시 나눈다.
* 이진 탐색
  * Divide : 리스트를 두 개의 서브 리스트로 나눈다.
  * Conquer :
    * 검색할 숫자 > 중간값 이면, 뒷 부분의 서브 리스트에서 검색할 숫자를 찾는다.
    * 검색할 숫자 < 중간값이면, 앞 부분의 서브 리스트에서 검색할 숫자를 찾는다.





## 이진 탐색 구현

* 내가 구현한 위치 리턴하는 이진 탐색

```java
import java.util.ArrayList;

public class DivideSearch {

  public int search(ArrayList<Integer> dataList, int searchItem) {
    int start = 0;
    int size = dataList.size() - 1;

    if (searchItem == dataList.get(start)) {
      return start;
    }

    while(size > 1) {
      if(size % 2 == 1) {
        if(searchItem > dataList.get(start + size / 2)) {
          start = start + size / 2;
          size = size / 2 + 1;
        } else if (searchItem == dataList.get(start + size / 2)) {
          return start + size / 2;
        } else {
          size = size / 2;
        }
      } else {
        if(searchItem > dataList.get(start + size / 2)) {
          start = start + size / 2;
          size = size / 2;
        } else if (searchItem == dataList.get(start + size / 2)) {
          return start + size / 2;
        } else {
          size = size / 2;
        }
      }
    }
    if(searchItem == dataList.get(start + 1)) {
      return start + 1;
    } 
    return -1;
  }
  public static void main(String[] args) {
    ArrayList<Integer> testList = new ArrayList<Integer>();

    for(int i = 1 ; i <= 100 ; i++) {
      testList.add(i);
    }
    
    DivideSearch dSearch = new DivideSearch();
    System.out.println(testList);
    System.out.println(dSearch.search(testList, 101));
  }
}
```

* 다시 내 구현

~~~java
package DataStructure;

import java.util.ArrayList;

public class BinarySearch {
  public Integer search(ArrayList<Integer> list, int searchItem) {
    if(list.size() < 1) {
      return null;
    } else {
      int n = list.size() / 2;

      if(list.get(list.size() / 2) == searchItem) {
        return n;
      }

      while(list.size() != 0) {
        if(list.get(list.size() / 2) < searchItem) {
          list = new ArrayList<Integer>(list.subList(list.size() / 2 + 1, list.size()));
          n += list.size() / 2 + 1;
          
          if(list.get(list.size() / 2) == searchItem) {
            return n;
          }
        } else if(list.get(list.size() / 2) > searchItem) {
          list = new ArrayList<Integer>(list.subList(0, list.size() / 2));
          if(list.size() % 2 == 1) {
            n = n - (list.size() / 2 + 1);
          } else {
            n -= list.size() / 2;
          }

          if(list.get(list.size() / 2) == searchItem) {
            return n;
          }
        }
      }
      return null;
    }
  }

  public static void main(String[] args) {
    ArrayList<Integer> list = new ArrayList<Integer>();
    for(int i = 0 ; i < 101 ; i++) {
      list.add(i);
    }
    BinarySearch bSearch = new BinarySearch();
    System.out.println(bSearch.search(list, 0));
    System.out.println(list.get(bSearch.search(list, 0)));
  }
}
~~~



* 강사님이 구현한 boolean 이진 탐색

~~~java
import java.util.ArrayList;
import java.util.Collections;

public class DivideSearch2 {
  public boolean searchFunc(ArrayList<Integer> dataList, Integer searchItem) {
    if(dataList.size() == 1 && searchItem == dataList.get(0)) {
      return true;
    }
    if(dataList.size() == 1 && searchItem != dataList.get(0)) {
      return false;
    }
    if(dataList.size() == 0) {
      return false;
    }

    int medium = dataList.size() / 2;

    if(searchItem == dataList.get(medium)) {
      return true;
    } else {
      if(searchItem < dataList.get(medium)){
        return this.searchFunc(new ArrayList<Integer>(dataList.subList(0, medium)), searchItem);
      } else {
        return this.searchFunc(new ArrayList<Integer>(dataList.subList(medium, dataList.size())), searchItem);
      }
    }
  }

  public static void main(String[] args) {
    ArrayList<Integer> testList = new ArrayList<Integer>();

    for(int i = 0 ; i < 100 ; i++) {
      testList.add((int)(Math.random() * 100));
    }

    Collections.sort(testList);
    
    DivideSearch2 dSearch2 = new DivideSearch2();
    
    System.out.println(testList);
    System.out.println(dSearch2.searchFunc(testList, 1));

  }
}

~~~





### 이진탐색 알고리즘 분석

* n개의 리스트를 매번 2로 나누어 1이 될 때까지 비교연산을 k회 진행하기 때문에
* O(log n + 1) => O(log n)
