# 삽입 정렬

* 두 번째 인덱스부터 / 해당 인덱스 앞에 인덱스부터 key 값을 비교해서 key 값이 더 작으면 인덱스 서로 변경
* 이를 key 값이 더 큰 데이터를 만날때까지 반복

## 구현

* 내 구현

~~~java
package DataStructure;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Arrays;

public class InsertSort {
  public ArrayList<Integer> sort(ArrayList<Integer> list) {
    for(int i = 1 ; i < list.size() ; i++) {
      while(i > 0 && list.get(i) < list.get(i - 1)) {
        Collections.swap(list, i, i - 1);
        i--;
      }
    }
    return list;
  }     

  public static void main(String[] args) {
    InsertSort iSort = new InsertSort();
    ArrayList<Integer> list = new ArrayList<Integer>();
    list.addAll(Arrays.asList(4,23,6,7,4,5,2,83,67,9,5,4,1,56,7,4));

    ArrayList<Integer> iList = iSort.sort(list);
    System.out.println(iList);
  }
}
~~~



* 강사님이 구현한 것

* for 바깥 부분을 계속 몇 번 돌지로만 설정해둠

~~~java
import java.util.ArrayList;
import java.util.Collections;

class Insert {
  public ArrayList<Integer> sort(ArrayList<Integer> dataList) {
    for(int index = 0 ; index < dataList.size() - 1 ; index++) {
      for(int index2 = index + 1 ; index2 > 0 ; index2--) {
        if(dataList.get(index2) < dataList.get(index2 - 1)) {
          Collections.swap(dataList, index2, index2 - 1);
        } else {
          break;
        }
      }
    }
    return dataList;
  }
}

public class InsertSort {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        for(int i = 0 ; i < 100 ; i++) {
            list.add((int)(Math.random() * 100));
        }
        Insert insert = new Insert();
        System.out.println(insert.sort(list));
    }
}
~~~



## 시간 복잡도

* 반복문 두 개 중첩이므로 $O(n^2)$
  * 자세하게 쓰면 $O(\frac{n(n-1)}{2})$
* 완전 정렬 되어있으면 O(n)

