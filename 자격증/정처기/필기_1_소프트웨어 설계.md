1. **소프트웨어 생명 주기 Software Development Life Cycle**

   * Waterfall Model
     * 타당성검토-계획-요구분석-설계-구현-테스트-유지보수

   * Prototype Model, 원형
     * 인터페이스 중점 개발, 요구사항 변경 용이

   * Spiral Model, 점진적
     * 위험분석 추가형 모델
     * 계획 및 정의-위험 분석-공학적 개발-고객평가

   * Agile Model
     * 고객과의 소통에 초점을 중점으로 개발 변화 유연 대응
     * sprint를 반복해서 개발
     * XP, 스크럼, 칸반, 크리스탈, 린

2. **스크럼 기법**

   * Sprint 2~4주 정도 기간으로 진행
   * PO - 요구사항 담긴 백로그 작성 주체
   * SM(스크럼 마스터) - 팀원들 통제 목표
   * DT - 나머지 인원 7~8명
   * 스프린트 계획 회의 - 스프린트 - 일일 스크럼 - 스크럼 검토 회의 - 스프린트 회고

3. **XP (eXtreme Programming) 기법**

   * XP 핵심가치
     * 용기, 단순성, 의사소통, 피드백, 존중
   * XP 기본원리
     * 전체 팀
     * 소규모 릴리즈
     * 테스트 주도 개발
     * 계속적인 통합
     * 공동 소유권
     * 짝 프로그래밍
     * 디자인 개선 or 리팩토링

4. **개발 기술 환경 파악**

   1. OS
      * 가용성, 성능, 기술지원, 구축비용, 주변기기
   2. 미들웨어
      * 운영체제와 응용 프로그램 사잉에서 추가적인 서비스를 제공하는 소프트웨어
   3. DBMS
      * JDBC, ODBC
      * Oracle, MySQL
      * 가용성, 성능, 기술지원, 구축비용, 상호 호환성
   4. WAS 웹 어플리케이션 서버
      * 정적인 컨텐츠를 처리하는 웹 서버와 반대됨
      * 동적인 컨텐츠를 처리하기 위해 사용되는 미들웨어
      * 가용성, 성능, 기술지원, 구축비용
   5. 오픈 소스
      * 라이선스의 종류, 사용자 수, 기술의 지속 가능성

5. **요구사항 정의**

   1. 기능 요구사항
      * 기능, 입력, 출력, 저장, 수행
   2. 비기능 요구사항
      * 성능, 품질, 제약사항, 호환성, 보안
   3. 요구사항 개발 프로세스
      * 도출/추출 - 분석 - 명세(Specification) - 확인/검증
   4. 요구사항 분석 기법
      * 요구사항 분류, 개념 모델링(UML), 요구사항 할당, 요구사항 협상, 정형 분석
   5. 요구사항 확인 기법
      * 요구사항 검토, 프로토타이핑, 모델 검증, 인수 테스트

6. **개념 모델링 UML**

   1. 구성 요소
      * 사물, 관계, 다이어그램
        * 사물 - 구조, 행동, 그룹, 주해 {사물}
        * 관계 - 연관(ㅡ), 집합(◇), 포함(◆), 일반화(ㅡ▷), 의존(-->), 실체화(--▷), {관계}
        * 구조적, 정적 다이어그램
          * 클래스, 객체, 컴포넌트, 배치(Deployment), 복합체 구조, 패키지, {다이어그램}
          * 컴포넌트, 배치 다이어그램은 구현 단계에서 사용되는 다이어그램
        * 행위, 동적 다이어그램
          * 유스케이스(사용사례), 시퀀스, 커뮤니케이션, 상태, 활동, 상호작용 개요, 타이밍 {다이어그램}

7. **UI**

   1. UI 구분
      1. CLI (Command Line Interface)
      2. GUI (Graphical User Interface)
      3. NUI (Natural User Interface) - 말, 행동으로 조작
      4. VUI (Voice User Interface) - 음성으로 조작
      5. OUI (Organic User Interface) - 모든 사물과 사용자 간의 상호작용을 위한 인터페이스
   2. UI 기본 원칙
      * 직관성, 유효성, 학습성, 유연성
   3. 웹의 3요소 - 웹 표준, 웹 접근성, 웹 호환성
   4. UI 설계 도구
      * 와이어프레임 - 레이아웃 협의 공유를 위해 사용
      * 스토리보드 - 최종적으로 참고하는 작업 지침서, 작업 산출물
      * 프로토타입 - 테스트 가능한 동적인 모형
      * 목업 - 실제 화면과 유사한 정적인 모형
      * 유스 케이스 - 사용자 측면 요구사항을 다이어그램 형식으로 묘사
   5. UI 프로토타입
      * 단점 : 작업시간 증가, 부분적인 프로토타이핑으로 인한 중요한 작업 생략 가능성
   6. UI 시나리오 문서 요건
      * 이해성, 완전성, 일관성, 가독성, 수정 용이성, 추적 용이성
   7. 기타
      1. HCI - 사람과 컴퓨터의 상호작용 연구해서 컴퓨터를 편리하게 사용하도록 만드는 학문
      2. UX - 사용자가 이용하면서 느끼는 경험 / 주관성, 정황성, 총체성
      3. 감성공학 : 1류 : 인간의 감성 / 2류 : 심리적 기능 / 3류 : 공학적 및 수학적 모델, 객관적

8. **품질 요구사항**

   1. 국제 제품 품질 표준
      * ISO/IEC 9126
        * 기능성, 신뢰성, 사용성, 효율성, 유지 보수성, 이식성
      * ISO/IEC 12119
      * ISO/IEC 14598
        * 반복성, 재현성, 공정성, 객관성
      * ISO/IEC 25000 : SW 품질 평가 통합 모델, SQuaRE, 3개 표준 통합
        * 품질관리, 품질 모델, 품질 측정, 품질 요구, 품질 평가
   2. 국제 프로세스 품질 표준
      * ISO/IEC 9001
      * ISO/IEC 12207
      * ISO/IEC 15504
      * CMMI

9. **소프트웨어 아키텍처**

   * 기능적 요구사항을 구현하는 방법을 찾는 해결 과정
     1. 모듈화 
     2. 추상화 - 과정 추상화, 데이터 추상화, 제어 추상화
     3. 단계적 분해 - 하향식 설계 전략, 추상화 반복으로 세분화, 상세 내역은 가능한 한 뒤로 미루어 진행
     4. 정보 은닉 

10. 아키텍처 패턴

    1. 레이어 패턴 - OSI 계층으로 구분하여 구성
    2. 클라이언트 서버 패턴 - 하나의 서버, 다수 클라이언트 컴포넌트로 구성
    3. 파이프 필터 패턴 
       * 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화해 파이프를 통해 데이터를 전송하는 패턴
       * 필터 컴포넌트는 재사용성이 좋고, 추가가 쉬워 확장이 용이
    4. 모델 뷰 컴트롤러 패턴
       * 서브시스템을 3개로 구조화
       * 모델 - 서브시스템 핵심 기능과 데이터를 보관
       * 뷰 - 사용자에게 정보 표시
       * 컨트롤러 - 사용자로부터 받은 입력 처리, 뷰 제어, UI 담당
    5. 마스터 슬레이브 패턴 - 장애 허용 시스템, 병렬 컴퓨팅 시트메
    6. 브로커 패턴 - 분산 환경
    7. 피어 투 피어 패턴 - 멀티 스레딩 방식
    8. 이벤트 버스 패턴 - 이벤트를 생성(소스), 수행(리스너), 통로(채널), 채널 관리(버스)
    9. 블랙보드 패턴 - 해결책이 명확하지 않은 문제 처리, 음성인식, 차량식별, 신호해석
    10. 인터프리터 패턴 - 코드 해석 컴포넌트 설계시 사용

11. 객체지향

    1. 객체
       * 객체가 반응할 수 있는 메시지의 집합의 행위(연산, Method)
    2. 클래스
       * 하나 이상의 유사한 객체들을 묶어서 공통된 특성을 표현한 것
       * 공통 속성과 연산을 갖는 객체집합
       * Super (부모), Sub (자식)
    3. 인스턴스
       * 클래스에 속한 각각 객체
       * 클래스로부터 새로운 객체 생성하는 것을 인스턴스화라고 함
    4. 메서드
       * 클래스로부터 생성된 객체를 사용하는 방법
    5. 메시지
       * 객체에게 어떤 행위를 하도록 지시하기 위한 방법
    6. 캡슐화
       * 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것
       * 인터페이스를 제외한 세부 내용이 은폐됨
       * 인터페이스가 단순해져서 재사용이 용이
       * 결합도 Down, 응집도 Up
    7. 상속
    8. 다중상속
    9. 다형성
       * 하나의 메시지에 대해 각 객체가 가지고 있는 특성으로 응답할 수 있는 능력

12. 결합도

    * 결합도가 낮을수록 독립적인 모듈이기에 좋은 것임
    * 내공외제스자 (Bad -> Good)
    * 내용 결합도 - 직접 참조
    * 공통 결합도 - 전역변수
    * 외부 결합도 - 순차적 (외부 참조)
    * 제어 결합도 - 제어 요소 전달 결합도
    * 스탬프 결합도 - 모듈 간 인터페이스로 배열이나 레코드 등 자료 구조가 전달될 때 결합도
    * 자료 결합도 - 데이터 넘기고 처리 결과를 리턴하는 결합도

13. 응집도

    * 모듈 내부 요소들의 관련되어 있는 정도
    * 높을수록 독림적인 모듈
    * 우논시절통순기
    * 우연적 응집도 - 관련 없는 요소로만
    * 논리적 응집도 - 유사 성격 특정 형태로 분류되는 요소들로 하나의 모듈이 형성
    * 시간적 응집도 - 특정 시간에 처리되는 기능
    * 절차적 응집도 - 순차적으로 수행할 경우
    * 통신적 응집도 - 동일한 입출력으로 다른 기능 수행하는 요소
    * 순차적 응집도 - 출력값으로 다음 입력 데이터 사용할 경우
    * 기능적 응집도 - 모든 기능 요소들이 단일 문제와 연관

14. 공통 모듈

    * 정확성
    * 명확성
    * 완전성
    * 일관성
    * 추적성
    * 재사용 규모에 따른 분류 - 함수와 객체, 컴포넌트, 애플리케이션

15. 코드

    * 식별, 분류, 배열, 간소화, 표준화, 연상, 암호화, 오류 검출 {기능}
    * 순차 코드 - 차례로 일련번호를 부여하는 방법
    * 블록 코드 - 공통성이 있는 것끼리 블록으로 구분해서 부여
    * 10진 코드 - 0~9까지 10진 분할하고, 다시 각각에 대해 10진 분할
    * 그룹 분류 코드 - 일정 기준에 따라 그룹으로 구분 후 부여
    * 연상 코드 - 명칭이나 약호로 코드 부여
    * 표의 숫자 코드 (유효숫자코드) - 물리적 수치 그대로 코드 부여
    * 합성 코드 - 2개 이상 코드를 조합
    * 코드 부여 체계 - 이름만으로 용도와 적용 범위 알도록 코드 부여

16. 디자인 패턴

    * 아키텍처 패턴이 디자인 패턴보다 상위 수준의 설계에 사용됨
    * 서브 시스템에 속하는 컴포넌트들과 그 관계를 설계하기 위한 참조 모델
    * 아키텍처 패턴은 전체 시스템 구조 설계를 위한 참조모델임

    1. 생성 패턴
       * 추상 팩토리 - 서로 연관된 객체들을 그룹으로 생성해 추상적으로 표현
       * 빌더 - 객체 생성과정과 표현방법을 분리 -> 동일 객체 생성에도 서로 다른 결과
       * 팩토리 메소드 - 객체 생성을 위한 인터페이스를 정의하여, 어떤 클래스가 인스턴스화 될 것인지는 서브 클래스가 결정하도록 하는 것(Virtual-Contructor 패턴)
       * 프로토타입 - 원본 객체를 복제하는 방법
       * 싱글톤 - 하나의 객체를 여러 프로세스가 동시에 참조할 수 없음
    2. 구조 패턴
       * 어댑터
       * 브리지
       * 컴포넌트
       * 데코레이터
       * 퍼싸드
       * 플라이웨이트
       * 프록시
    3. 행위 패턴
       * 책임 연쇄
       * 커맨드
       * 인터프리터
       * 반복자
       * 중재자
       * 메멘도
       * 옵저버
       * 상태
       * 전략
       * 템플릿 메서드
       * 방문자
       * 생성 패턴과 구조 패턴이 아니면 행위패턴임

17. 인터페이스 요구사항 검증

    1. 요구사항 검증
       * 인터페이스 요구사항 검토 계획 수립 - 검토 및 오류 수정 - 베이스라인 설정
    2. 요구사항 검증 방법
       * 동료 검토 - 요구사항 명세서 작성자가 내용 설명 후 동료가 결함 발견
       * 워크 스루 - 검토 전 요구사항 명세서 미리 배포 후 사전 검토 후, 짧은 검토 회의를 통해 결함 발견
       * 인스펙션 - 요구사항 명세서 작성자 제외한 다른 검토 전문가들이 결함 발견
    3. 인터페이스 요구사항 검증 주요 항목
       * 기능성, 완전성, 일관성, 명확성, 검증 가능, 추적 가능성, 변경 용이성

18. 인터페이스

    1. 인터페이스 식별 - 요구사항 명세서, 요구사항 목록으로 인터페이스 목록 작성
    2. 인터페이스 시스템 식별 - 송신 시스템과 수신 시스템으로 구분하여 작성
    3. 인터페이스 표준 항목
       * 시스템 공통부 - 시스템 간 연동시 필요한 공통 정보
       * 거래 공통부 - 시스템 연동된 후 송, 수신 데이터 처리시 필요 정보

19. 인터페이스 방법 명세화

    1. 시스템 연계 기술
       1. 직접 연계 방식
          * DB 링크
          * DB 연결
          * API/Open API
          * JDBC
          * 하이퍼 링크
       2. 간접 연계 방식
          * 소켓
          * 웹 서비스
          * ESB(Enterprise Service Bus)
    2. 인터페이스 통신 유형
       * 단방향 / 동기, 비동기
    3. 인터페이스 처리 유형
       * 실시간 방식, 지연 처리 방식(비용이 많이 발생할 때), 배치 방식(대량의 데이터 처리)
    4. 인터페이스 발생 주기

20. 미들 웨어 솔루션 명세

    * OS와 프로그램 사이에 OS가 제공해주지 못하는 서비스를 제공하는 소프트웨어

    1. DB
    2. RPC(Remote Procedure Call) - 응용 프로그램 프로시저를 사용해 원격 프로시저를 로컬 프로시저처럼 호출하는 미들웨어
    3. MOM(Message Oriented Middleware) - 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어
       * MQ, Message Q, JMS
    4. TP-Monitor(Transaction Processing Monitor)
       * 빠른 응답속도를 유지해야하는 업무에 주로 사용
       * tmax, tuxedo
    5. Legacyware
       * 새로 업데이트된 기능을 덧붙이고자 할 때 사용
    6. ORB(Object Request Broker)
       * 객체 지향 미들웨어로 CORBA 표준 스펙을 구현
       * CORBAR - 네트워크에서 분산 프로그램 객체 생성, 배포, 관리하기 위한 규격을 의미
    7. WAS