# 정수론

## 유클리드 알고리즘

* 두 수의 최대공약수를 구하는 알고리즘

  여기서 중요한 것은 소인수분해를 하지 않고 구하는 방법이다. 소인수분해는 알고리즘 관점에서 비효율적이기 때문이다.

  시간 복잡도를 O(N) => O(log N)으로 줄일 수 있는 알고리즘.

  * 정리

    음 아닌 정수 a와 양의 정수 b가 있다고 하자. 만약 b | (r-a)라면, gcd(a, b) = gcd(b, r)이다.

  * 증명

    r - a = bq를 만족하는 q가 있다. c는 a와 b의 공약수라 하자.

    r = bq + a 이고, 우변은 c의 배수이므로 r = bq + a = w * c

    즉, c는 r의 약수이다.

    반대로 c는 b와 r의 공약수라 하자.

    r - a = bq는 a = r - bq이므로 c는 a의 약수도 된다.

    즉 gcd(a, b) = gcd(b, r)이다.

  * 간단하게 생각해보면 r - a가 b를 나눌 수 있으면, b와 a에 대한 공약수들은 b와 r에 대한 공약수들에 포함된다.

  * 예시

    gcd(56, 21)를 구해보자

    ​	56 % 21 => 14

    ​	gcd(56, 21) = gcd(21, 14)

    ​	21 % 14 => 7

    ​	gcd(56, 21) = gcd(21, 14) = gcd(14, 7)

    ​	14 % 7 => 0

    ​	gcd(56, 21) = gcd(21, 14) = gcd(14, 7) = 7

    ​	gcd(56, 21) = 7;

    

~~~java
public int euclid(int a, int b) {
  if (a < b) {
    int c = a;
    a = b;
    b = c;
  }
  while(b != 0) {
    r = a % b;
    a = b;     
    b = r;
  }
  return a;
}
~~~



* 추가

  * gcd(a, b) = d 라고 하면, ax + by = d 를 만족하는 정수 해 x, y가 존재한다.

    * 84x + 55y = 1을 만족하는 정수 해 x, y를 구해보자.

      * 풀이 방법은 유클리드 알고리즘을 역방향으로 반복적으로 풀면 된다.

        ~~~
        1. 84 - 55 * 1 = 29
        2. 55 - 29 * 1 = 26
        3. 29 - 26 * 1 = 3
        4. 26 - 3 * 8 = 2
        5. 3 - 2 * 1 = 1
        6. 2 - 1 * 2 = 0
        7. 1, 0
        
        a7 + b7 = 1
        a7 = b6, b7 = a6 - 2 * b6
        
        a6 - b6 = 1
        a6 = b5, b5 = a5 - 3 * b5
        
        -a5 + 2 * b5 = 1
        a5 = b4, b5 = a4 - 8 * b4
        
        2 * a4 - 17 * b4 = 1
        a4 = b3, b4 = a3 - b3
        
        -17a3 + 19a3 = 1
        a3 = b2, b3 = a2 - b2
        
        19a2 - 36b2 = 1
        a2 = b1, b2 = a1 - b1
        
        -36a1 + 55b1 = 1
        -36 * 84 + 55 * 55 = 1
        ~~~

        