# SW Expert Academy

## 프로그래밍과 논리/수학

### 하드 로직과 소프트 로직의 차이

* 하드 로직

  ​	   문제1

  * 사실 : 모든 카드의 한 쪽에는 알파벳, 다른 쪽에는 숫자

  * 주장 : 만약 한 쪽이 D면 반대쪽에는 숫자 3

  * 문제 : 주장이 사실인지 확인하기 위해 아래 카드 중 반드시 뒤집어 봐야 하는 카드는 몇 개이고, 어느 것인가.

  *  D 카드 / F 카드 / 3 카드 / 7 카드

  * 정답 : D 와 7

    문제 2

  * 규칙 : 20세 이하인 사람은 맥주를 마실 수 없음

  * 문제 : 나이 혹은 마시고 있는 것을 표시한 다음 4명 중 확인이 필요한 사람은 누구인가

  * 17세 / 31세 / 콜라 / 맥주

  * 정답 : 17세, 맥주

* 위 두 문제는 똑같은 로직이지만 다르게 품...
* 맥주집 문제를 풀 때는 직관을 사용한 것이고, 직관은 논리적인 느낌을 준다.
* 익숙한 상황에서 매우 빠르게 파악하지만, 정확하지 않고, 강한 착각을 일으킴



* inclusive or / exclusive or

  합격하려면 토플 500점 이상 혹은 토익 600점 이상 => inclusive or

  복권에 당첨하면 자동차 혹은 천만원 드립니다. = > exclusive or

* soft logic으로 알고리즘을 이해하려고 하면 안됨.
* 알고리즘 설명을 보고 또 봐도 이해가 안되는 것은 증명을 안 봤기 때문이다.



### 논리 연습

* 문제 1

  * 만약 0이 홀수라면, 미국에서 월드컵이 열린다.
    * p 이면 q이다. 가정이 거짓이면 명제는 무조건 참이 된다.
    * 그렇기에 0은 홀수가 아니므로 이 명제는 무조건 참이 된다.
  * 100점을 맞으면 치킨을 사줄 것이다.
    * 100점을 맞았을 때 치킨을 사준다. => 참
    * 100점을 맞았을 때 치킨을 사주지 않는다. => 불
    * 100점을 맞지 않았을 때 치킨을 사준다. => 참
    * 100점을 맞지 않았을 때 치킨을 사주지 않는다. => 참 => 가정이 거짓이기 때문에 이 명제는 참이다.

  * 123141543가 prime넘버라면 2는 짝수이다.
    * p이면 q이다 에서 q가 참이면 p가 무엇이든 이 명제는 참이다.

* 문제 2

  * p -> q가 거짓이라 하면

    ~p -> q  / p v q / q -> p 


    p -> q가 거짓이려면 하나밖에 없다. p가 참이고 q가 거짓이어야 한다.

    ~p -> q 는 ~p가 거짓이기 때문에 무조건 참

    p v q 는 p or q 이기에 참

    q -> p 는 p가 참이기 때문에 무조건 참



### 증명

* 정확한 명제식으로 표현할 수 있는 것

#### 당구공 Paradox

* 모든 당구공은 색이 같다는 다음 증명에서 잘못된 것은?
  * 수학적 귀납법 : P(1)이 참이고, P(n) => P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해서 참이다.
  * 모든 자연수 n에 대해 당구공 n개가 들어있는 집합에서 그 집합에 포함됨 당구공은 모두 색이 같다는 것을 증명함
  * P(1) : 당구공 1개 모든 색은 같다 참
  * P(n) : 당구공 n개 모든 색은 같다를 참으로 둘 때
  * P(n+1)은 참인가??
    * P(n+1)에서 하나의 당구공을 빼면 P(n)이 된다. 그러면 참!
    * P(n)에서 방금 뺀 당구공을 넣고 다른 당구공을 뺀다. 그러면 참!
    * 그러므로 둘 다 넣은 P(n+1)은 참이다.
  * 이 증명이 맞을까?? 여기서 잘못된 점이 무엇인가??
    * P(n)이 참인지 거짓인지에 대해서는 문제를 삼을 이유가 없다.
    * 여기서 둘 문제는 처음 뺀 당구공과 두번 째로 뺀 당구공의 색이 같은지를 모르기 때문에 이 곳에서 문제가 일어난 것.

#### Infinitely Many Prime Numbers

* Prime Number의 개수가 유한한 k개라고 가정

* 모든 Prime Number를 다 곱하고 1을 더한 수를 n이라고 하자

* 이 수 n은 어떤 Prime으로 나누어도 나머지가 1이다.

* 그런데 n은 어떤 Prime보다도 크므로 합성수이다.

* 합성수이지만 어떤 Prime으로도 나누어지지 않으므로 모순 발생

  * Prime Number가 유한개이면 모순이 발생하므로 Prime number가 유한개인 것은 거짓.
  * 그렇기 때문에 이 명제는 언제나 참이 된다....

  

* 알고리즘은 수학적 귀납법으로 해결해야 하는 경우가 많다

  * 수학적 귀납법의 기본형

    P(1)이 참이고 P(n) -> P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해 참이다.

  * 수학적 귀납법의 강한형태

    P(1)이 참이고 P(1)^P(2)^P(3) ... ^P(n) -> P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해서 참이다.

    

#### sum(x)가 리턴하는 값은 1+2+3+ ... +x의 값과 항상 같다.

```java
int sum(int n) {
  if(n < 1) { return 0;}
  return n + sum(n-1);
}
```

* P(1) 참이다 : sum(1)이 리턴하는 값이 1이다. 를 증명.

* P(x) -> P(x+1)이 참이다. : sum(x-1)이 1+2+3+...+(x-1)을 리턴하면 

  ​										sum(x)는 1+2+3+...+x를 리턴한다. 를 증명

  * sum(x) 는 x + sum(x-1)을 리턴하므로 sum(x-1)의 리턴 값이 1+2+...+(x-1)을 리턴한다고 가정했으니 sum(x)는 1+2+...(x-1)+x를 리턴함을 확인할 수 있음.
  * 즉 이 명제는 참이다.

* 여기서 sum(x-1)이 참인지 거짓인지를 판단할 이유가 없음. sum(x-1)을 가정을 하고 sum(x)에서 똑같이 sum(x-1)에 대해 같은 내용으로 두면 된다.
* 수학적 귀납법에서 P(n)이 참인지 거짓인지를 판단하지 않고 P(n+1)이 참인지 거짓인지 확인할 때 P(n)에 적용한 가정을 똑같이 적용하기만 하면 되기 때문에

#### 버블 정렬의 증명

* 소팅이 된다는 것을 직관적인 수준에서 설명하는 경우가 많다.
* 상세한 증명을 위해서는 증명이 가능한 명제가 필요하다.
* 소팅이 되었다? (증명 불가) / A 배열을 소팅했을 때 A[1] < A[2] < A[3] ... < A[n] 이다?(가능한 증명)

* 버블 정렬이 정확하다는 것을 어떻게 증명할 것인가?

  ```java
  if(list.get(i) > list.get(i + 1)) {
    Collections.swap(list, i, i + 1);
  }
  /*
  list.get(n - 1) > list.get(n)이면 value값이 스왑됨. 그래서 list.get(n-1)보다. list.get(n)이 더 크다.
  list.get(n) > list.get(n+1)이면 서로 값이 스왑되므로 list.get(n)보다 list.get(n+1)이 더 크다.
  그래서 list[1] < list[2] ... < list[n-1] < list[n] 이다...
  이게 맞는 증명인가?
  */
  ```

  
